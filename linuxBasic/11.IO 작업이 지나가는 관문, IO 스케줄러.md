# 11.I/O 작업이 지나가는 관문, I/O 스케줄러
- I/O 작업은 가상파일 시스템, 로컬 파일 시스템등 경로를 거친 후 블록 디바이스로 전달되기 전에 I/O 스케줄러를 거치게 된다.
- `/sys/block/<block device>/queue/scheduler` : 현재 사용하는 스케줄러와 사용가능한 I/O스케줄러 정보를 확인할 수 있다.
## I/O 스케줄러의 필요성
#### 디스크 종류
- HDD  
    - 데이터를 읽을때 디스크 헤드를 플래터의 특정 위치로 움직이게 해야한다. 
    - 기계 장치라 이동시간이 소요되므로 헤드의 움직임을 최소화 하고 한번 움직일때 ㅚ대한 처리애햐 I/O성능이 극대화 된다.
- SSD
    - 전기적 신호를 이용해 접근하기 때문에 임의로 특정 섹터에 접근 할 때 소요되는 시간이 모두 동일하다.
#### I/O 스케줄러의 성능 극대화 작업
 커널은 I/O 스케줄러를 통해서 조금이라도 성능을 극대화 하려하고 이런 작업을 위해서 병합과 정렬 두가지 방법을 사용한다.
 - 병합 
    - 여러개의 요청을 하나로 합치는 것
    - RequestQueue 에 총 3개의 요청(각 10번 블록에서 1개 , 11번에서 1개, 12번에서 1개의 블록내용을 읽어오는 요청)이 있다면,  
        접근 블록이 인접해 있기 때문에 이 세개의 요청을 하나의 큰 요청으로 합쳐서 넘겨준다.
 - 정렬    
    - 여거래의 요청을 섹터 순서대로 재배치 하여 최적의 경로를 이용하도록 하는 것
    - 먼저 발생한 요청이 더 늦게 처리되는 문제가 있다.
    - SSD의 경우 헤드 이동 비용이 없으므로 정렬이 별 의미 없음

#### I/O 스케줄러 설정
- 각각의 I/O 스케줄러별로 튜닝 가능한 파라미터들이 다르다.
- `echo cfq > ./scheduler` : cfq I/O 스케줄러 변경하기
## I/O 스케줄러 종류
### cfq(Completely Fair Queueing) I/O 스케줄러
- 요청을 특성에 따라 RT(Real Time), BE(Best Effort), IDLE 중 하나로 분류하고 RT에 속한 요청들을 가장 먼저 처리하고 IDLE에 속한 요청들을 가장 나중에 처리한다.
- RT, BE IDLE 로 분류한 다음에는 service tree라 불리는 워크로드별 그룹으로 다시 나눈다.
    - SYNC : 순차적인 동기화 I/O 작업으로, 큐에 대한 처리를 완료한 후 일정 시간동안 대기한다.   
            순차 작업이기 때에 향후에 들어오는 I/O 요청도 현재 디스크의 헤드와 가까운 위치의 작업이 들어올문 확률이 높아서이다.  
             `slice-idle` 값으로 이 대기시간을 설정한다.
    - SYNC_NOIDLE : 임의적인 동기화 I/O 작업, 주로 임의 읽기를 의미한다.   
                    각 큐에 대한 처리 완료 후 대기 없이 바로 다음 큐 작업 시작
    - ASYNC : 비동기화 I/O 작업, 주로 쓰기 작업을 의미한다.  
                  동기화 I/O 작업들은 프로세스별로 큐를 가지고 있지만, 비동기 I/O작업은 ASYNC 서비스 트리밑에 하나로 모아놓고 한꺼번에 처리한다.
- 각 성질에 맞게 나뉜 I/O 요청들을 cfq queue에 넣고 각각 동등한 타임슬라이스를 할당한 다음 이 값을 기준으로 큐들을 순차적으로 처리한다.
- 모든 프로세스들에 치우침 없이 동등한 I/O 요청 처리 기회를 주지만, 일부 프로세스들에 대해 성능이 낮아질 수 있다.
#### cfq(Completely Fair Queueing) I/O 스케줄러 튜닝 파라미터
- `back_seek_max`   
    - 현재 디스크의 헤드가 위치한 곳을 기준으로 backward seeking 의 최대값을 의미한다. 
    - 현재 헤드 위치가 10이고 back_seek_max 가 5라면 5-10번까지의 요청들이 바로 다음 요청으로 간주되어 처리된다.
- `back_seek_penalty` 
    - backward seeking의 패널티를 정의한다.     
    - 헤드가 10번 섹터의 위치에서 15섹터로 가는 겨우와 5 섹터로 이동하는 경우, 똑같이 5만큼 이동하지만 5번 섹터로 갈때는 패널티를 부여해 성능에 좋지 않은영향을 주는 작업이라고 인지시킴
- `fifo_expire_async` 
    - fifo 리스트가 존재하고 그중에서 async 요청에 대한 만료 시간을 정의한다.
- `fifo_expire_async` 
    - sync 요청에 대한 만료시간을 정의
- `group_idle`
    - I/O 요청이 전부 처리되면 해당 큐는 idle상태가 된다.
    - 같은 cgroup 안에 포함된 프로세스들에 대해서는 큐를 이동할때 기다리지 ㅇ낳고 바로 다음큐로 넘어가지만,  
        다른 cgroup으로 넘어갈때는 group_idle(ms) 만큼 대기한다.
- `group_isolation`
    - 0 일때(defalut)
        - 서비스 트리중 SYNC_NOIDLE에 속하는 큐들을 croup의 루트 그룹으로 이동시켜 처리한다.
        - SYNC_NOIDLE은 임의 접근이므로 순차접근에 비해 시간이 오래 걸리고, cgroup별로 처리한다면 전체적인 성능이 더 낮아질 수 있다.
        - 이 경우 cgroup별로 설정한 값이 임의접근에는 적용되지 않는다.
    - 1 일때 
        - cgroup별로 설정한 값이 임의접근에도 적용되고 각각의 cgroup의 분류가 더 명확해진다.     
- `low_latency`
    - I/O 요청을 처리하다가 발생할 수 있는 대기시가능 줄이는 역할을 한다.
    - boolean 값으로 1(enable)/0(disable) 으로 설정
    - 1일 경우 각 큐에 time slice를 할당하기 전에 각 그룹별로 해당 그룹의 큐를 모두 처리하는 데 걸릴 시간을 계산하고,
    이 계산 결과가 300ms보다 크다면 이 값을 넘지 않도록 조절한다.
- `slice_idle`
    - 큐 처리를 완료하고 바로 다음 큐로 넘어가지 않고 slice_idle에 설정된 시간만큼 기다린다.
- `slice_sync`
    - cfq는 큐별로 time slice를 할당해서 I/O를 처리하고 해당 설정시간을 넘기면 다음 큐를 처리하도록 동작한다.  
     slice_sync는 sync요청에 대한 time slice 의 기준값을 의미한다.
- `slice_async`
    - 큐에 async요청이 있을때 설정되는 time slice 기준값
- `slice_async_rq`
    - cfq가 큐에서 한번에 꺼내서 dispatch queue에 넘기는 async 요청의 최대 개수
- `quantum`
    -sync 요청을 꺼내서 dispatch에 넘기는 최대 개수
    
### deadline I/O 스케줄러
- I/O 요청별로 완료되어야 하는 deadline을 가지고 있는 I/O 스케줄러
- 2개의 sorted list 와 fifo list 가 있고 sorted list 는 섹터 기준으로 정렬되어 있다.
- 평상시 sorted list 에서 정렬된 상태의 요청을 꺼내어 처리하지만 fifo list에 있는 요청들중 deadline을 넘긴 요청이 있다면
  fifo list 에 있는 요청을 꺼내서 처리하고 이후 처리된 요청을 기준으로 sorted list를 재정렬해서 그 이후의 I/O요청을 처리한다.

#### deadline I/O 스케줄러 튜닝 파라미터
- `fifo_batch`
    - deadline은 batch 라는 이름으로 다수의 I/O요청을 처리하는데, 이때 몇개의 I/O 요청을 전달할 것인지 결정하는 값
    - 기본값은 16개
- `front_merges`
    - 현재 헤더 위치의 앞쪽으로 I/O요청이 발생하는 경우도 있는데 이를 탐색하는 기능을 의미한다.
    - 기본값은 1(true)
- `read_expire`
    - 발생한 I/O요청 중 read 요청에 대한 deadline을 결정하는 값
    - 기본값은 500ms
- `write_expire`
    - 발생한 I/O요청 중 write 요청에 대한 deadline을 결정하는 값
    - 기본값은 5000ms
- `write_starved`
    - 쓰기 요청을 한번 처리에 대한 읽기 요청 처리 수
    - 단위는 횟수이며 기본값은 2이다
    - 읽기 요청을 2번(batch단위) 처리하면 쓰기요청을 1번(batch단위) 처리하는 식으로 동작한다.

### noop I/O 스케줄러
- 정렬은 하지 않고 병합 작업만 하는 I/O 스케줄러이다.
- 큐도 하나만 존재하며 인입된 I/O 요청에 대해 병합 할 수 있는지의 여부만 확인한 후 병합이 가능하면 병합 작업을 진행
- 플래시 디스크의 경우 임의의 접근에 대한 소요시간이 같기 때문에 정렬이 무의미하고, 정렬하는 시간소요로 오히러 성능 저하가 발생할 수 있기 때문에
  플래시 디스크에 사용권장되는 스케줄러이다.
- 튜닝 파라미터도 존재하지 않는다.



### cfq 와 deadline 의 성능 테스트 
- 순차 읽기/쓰기에 대해서는 성능차이가 거의 없다.
- 다수의 프로세스가 동등하게 I/O 요청을 일으키는 경우는 cfq가 더 나은성능을 보여준다.(=> 모든 프로세스가 비슷한 수준으로 I/O요청을 처리함)
- DB와 같이 특정 프로세스가 많은 양의 I/O 요청을 일으키는 경우에는 deadline이 더 효율적이다.
