# 2. top을 통해 살펴보는 프로세스 정보들

## **`top`**
- top은 시스템의 상태를 전반적으로 가장 빠르게 파악할 수 있는 명령 중 하나이다.
- 옵션 없이 입력하는 경우 주어진 Interval 간격(기본 3초)으로 화면을 갱신하면서 정보를 보여준다.
- **`top 명령어를 통해 알 수 있는 정보`**
    1. 현재 서버의 시간과 서버가 얼마동안 구동되었는지에 대한 시간
    2. 사용자수와 Load 
        - Load Average는 현재 시스템이 얼마나 많은일을 하는지에 대한 수치
    3. 현재 시스템에서 구동중인 프로세스 개수
    4. CPU, Mem, swap 메모리의 사용
    5. 각 프로세스의 상세 정보 
        - PID, 메모리 사용률, 상태, CPU 점유 시간
        - PR : 프로세스 실행 우선 순위 
        - NI : PR을 얼마만큼 조절할 것인지 결정 
            > 기본 PR값에 NI값을 더해서 실제 PR의 값이 결정된다.
        - VIRT, RES, SHR : 프로세스가 사용하는 메모리의 양이 얼마인지 확인 할수 있는 정보
        - S : 프로세스의 상태를 나타내는 정보로 현재 CPU를 사용하면서 작업하는 상태인지, I/O를 기다리는 상태인지, 아무작업도 하지 않는 유휴 상태인지를 표시
        

### VIRT, RES, SHR
- **VIRT** : task(프로세스)가 사용하고 있는 virtual memory의 전체 용량     
- **RES** : 현재 task가 사용하고 있는 물리 메모리의 양
    > VIRT는 실제 할당되지 않은 가상의 공간이기 때문에 해당 값이 커도 문제가 되진 않는다. 실제 사용하고 있는 메모리는
    RES영역이기 때문에 메모리 점유율이 높은 프로세스를 찾기 위해서는 RES영역이 높은 프로세스를 찾아야 한다.
- **SHR** : 다른 프로세스와 공유하고 있는 chared memory의 양  
   > 대부분의 리눅스 프로세스들은 glibc라는 라이브러리를 참조하는데 사용하는 프로세스마다 glibc의 내용을 
   메모리에 올려서 사용하는 것은 공간 낭비 이다. 이때문에 커널은 공유메모리라는 개념을 도입했고, 
   다수의 프로세스가 함께 사용하는 라이브러리는 공유메모리 영역에 올려서 함께 사용하도록 구현했다.

## Memory Commit
### Memory Commit
프로세스가 커널에 필요한 메모리를 요청하면 커널은 프로세스에 사용 가능한 메모리 영역을 주고 
실제로 할당은 하지 않지만, 해당 영역을 프로세스에 주었다는 것을 저장해둔다.
프로세스가 할당받은 메모리 영역을 사용할 때 실질적인 물리 메모리 할당을 시작하며 이런 일련의 과정을 Memory Commit이라고 부르며,
커널 파라미터의 `vm.overcommit_memory`를 통해 동작 방식(가상 메모리의 할당 가능 용량)을 정의할 수 있다.  
- `vm.overcommit_memory`  
0,1,2 세가지 값 중 하나로 세팅 가능하다.
    - 0 : 커널에서 사용하고 있는 기본 값 
        - 이 때 overcommit할 수 있는 최댓값 =  page cache + swap + slab reclaimble  
        - 위 값보다 작으면 계속 해서 commit 가능
    - 1 : 무조건 commit을 진행 
        - 가용메모리보다 훨씬 큰 메모리를 요청하는 일이 발생할 수 있다. 
        - 메모리 누수가 있는 프로세스가 있다면 시스테 응답 불가 현상을 일으킬 수도 있다.
    - 2 : 제한적으로 commit 진행한다. 
        -   값이 0일때와 같은 계산식이 적용, vm.overcommit_ratio에 설정된 비율과 swap영역의 크기를 토대로 계산된다. 
        - /proc/meminfo에서 값을 확인 가능하다.
        
    > swap 영역 이란 ??   
    프로세스의 메모리 할당요청이 들어왔는데, 시스템의 물리메모리가 부족한 상태일 경우 일시적으로 기존에 사용하던 물리메모리의 일부분을 저장 장치에 저장해 빈 공간을 만든다. 이때 메모리 내용이 저장된 영역을 스왑 영역 이라고 한다.

### 프로세스의 메모리 할당 과정
1. 프로세스는 malloc()과 같은 시스템 콜로 필요한 메모리의 영역의 할당요청   
2. 커널은 가용공간이 있다면 성공 메세지와 함께 해당 프로세스가 사용할 <u>가상의 메모리</u> 주소 전달    
3. 프로세스가 할당받은 메모리 영역에 실제로 쓰기작업을 하면 Page fault 가 발생한다.          
4. 커널이 실제 물리 메모리에 프로세스의 가상 메모리 공간 매핑하고 이는 Page Table 이라는 커널의 전역변수로 관리된다.  
5. 물리 영역에 바인딩된 영역이 RES로 계산된다.   
> - page fault 란..?  
    프로세스가 페이지 테이블 내 물리주소가 매핑 되지 않은 가상메모리 영역에 접근하면 페이지 폴트가 발생하고, 페이지 폴트가 발생하면 물리 메모리에 비어있는 프레임을 찾아 가상 메모리에 매핑 시켜준다.

### 커널이 Memory Commit을 사용하는 이유* 
fork() 시스템 콜을 사용하면 커널은 현재 실행중인 프로세스와 같은 fork()와 같은 새로운 프로세스를 만든다.  
fork() 이후 exec() 세스템 콜을 통해 전혀 다른 프로세스로 변하는데 이때 확보한 메모리 영역이 대부분 쓸모 없어질 수 도 있어서
COW(Copy-On-Write)라는 기법을 통해서 복사된 메모리 영역에 실제 쓰기 작업이 발생한 후에야 실질적인 메모리 할당을 시작한다. 
그리고 이런 작업을 지원하기 위해 Memory Commit이 필요하다.


### `sar`
- 현재 시스템의 Memory Commit 상태 확인
- %commit :  시스템 메모리 커밋 비율 (할당만 해주고 실제 사용하지 않는 메모리 양 / 전제 메모리 * 100)
- 커밋된 메모리의 비율이 높다면 순간적으로 시스템에 부하를 일으키거나 커널 응답 불가 현상을 일으킬 수도 있다.

## 프로세스 상태
top 명령어 실행시 SHR 옆에 있는 `S`항목으로 볼 수 있다.
상태값으로는 `D, R(running), S(sleeping), T(traced or stopped), Z(zombie)` 가 있다.  
- D(uninterruptible sleep)
    - 디스크 혹은 네트워크 I/O를 대기하고 있는 프로세스로 UNINTERRRUPTIBLE 상태로 마킹된 대기 상태이다.
    - 이 상태의 프로세스들은 대기하는 동안 Run Queue에서 빠져나와 Wait Queue에 들어가게 된다.
    - D상태의 프로세스가 많은것은 특정 요청이 끝나기를 기다리고 있는 프로세스가 많다는 뜻이다.
    - 이 프로세스들은 요청이 끝나면 R상태로 돌아가야 하기 때문에 시스템 부하를 계산하는데 포함된다.
- R(running)
    - 실행중인 프로세스 (실제 CPU 자원을 소모하고 있다)
- S(sleeping)
    - sleeping 상태의 프로세스로 언제든 시그널이 들어오면 받아서 처리할 수 있도록 INTERRUPTIBLE 상태로 마킹된 프로세스이다.
- T(traced or stopped)
    - starace등으로 프로세스의 시스템 콜을 추적하고 있는 상태
    - 보통 시스템에서는 자주 볼수 없는 상태의 프로세스 이다.
- Z(zombie)
    - 좀비 상태로 부모 프로세스가 죽은 자식 프로세스를 의미한다.
    - 사용 중지된 프로세스라 시스템의 리소스를 차지하지 않으므로 존재 자체는 큰 문제가 되지 않지만,
    좀비 프로세스가 PID 점유를 많이 하게 되면 새로운 프로세스에 할당할 pid가 부족해질 수 있다.
    > `kernel.pid_max`라는 커널 파라미터를 통해 pid 최대값을 정의할수 있고, `sysctl -a | grep -i pid_max` 명령어로 생성 가능한 최대 pid를 확인 할 수 있다.

## 프로세스 우선순위
- top 명령어 실행시 `PR 과 NI`의 값은 커널이 프로세스를 스케줄링 할 때 사용하는 우선순위를 나타낸다.
- **PR** : 커널에서 인식하는 해당 프로세스의 실제 우선순위 값
- **NI** : nice 값이라고 부르며 nice 명령어를 통해서 우선순위를 낮출 수 있다.
