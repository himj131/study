# 6.NUMA, 메모리 관리의 새로운 세계

### UMA(Uniform Memory Access) 아키텍쳐
- 초창기 아키텍쳐로 모든 프로세서가 공용 Bus를 이용해 메모리에 접근한다.
- BUS를 동시에 사용할 수 없다. 

### NUMA(Non-Uniform Memory Access) 아키텍쳐
- 불균형 메모리 접근이라는 뜻으로 멀티 프로세서 환경에서 적용되는 메모리 접근방식
- 로컬 메모리로의 접근이 동시에 이뤄질 수 있다.
- 로컬 메모리의 양이 부족할때 리모트 엑세스를 하게되며 성능이 저하될 수 있다.

> 각각 cpu마다 별도 메모리가 있고 이 둘을 묶어 노드라고 부른다.
> 노드 내부 메모리에 접근하는 방식을 로컬 엑세스(Local Access), 외부노드의 메모리에 접근하는 방식을 리모트 액세스(Remote Access)라고 한다.

### NUMA 확인하기
#### `numactl` 
- NUMA 와 관련된 정책을 확인하거나 설정하는 명령어
    - `numactl --show` : 정책 확인
    - `numactl -H` : 노드 구성 개수와 각 노드에 할당된 cpu 번호, 메모리 크기를 확인 할수 있다. 
    각 노드 메모리에 접근하는데 걸리는 시간도 확인 가능하다.
#### `numastat`
- NUMA 환경에서 현재 시스템에 할당된 메모리의 상태 확인
- 메모리 불균현 상태 확인 가능

#### `/proc/<pid>/numa_maps` 
- 현재 동작중인 프로세스의 메모리 할당 정책과 관련된 정보
 
#### NUMA와 관련된 메모리 할당 정책
1. **default**   
    - 현재 프로세스가 실행되고 있는 프로세서가 포함된 노드에서 먼저 메모리를 할당 받아 사용한다.
2. **bind** 
    - 특정 프로세스를 특정 노드의 cpu에 바인딩시키는 방식
    - 메모리 지역성이 좋아져 접근속도가 빨라져 성능이 좋아질 수 있지만, bind에 설정한 노드의 메모리가 부족하면 성능이 급격히 나빠질 수 있다.
3. **preferred**
    - bind와 비슷하지만 선호하는 노드를 설정해 가능한 한 설정한 노드로부터 메모리를 할당 받는다.
4. **interleaved**
    - 다수의 노드에서 거의 동일한 비율로 메모리를 할당 받는다.
    - Round-Robin 정책에 따라 다수의 노드로부터 한번씩 돌아가면서 메모리 할당 받는다.
    - 주로 한 노드이상의 메모리 할당이 필요한 경우에 사용   

#### 메모리 할당 정책별 특징
1. **default**   
    - 순간순간 프로세스가 동작하고 있는 cpu 기준으로 할당 받음
    - 0번 노드에 있는 cpu를 할당받아 동작하다가 1번노드 cpu를 할당받게되면,  
      기존 0번 노드에서 돌때 확보한 메모리를 로컬메모리가 아닌 원격 메모리가 된다.
    - 메모리 지역성이 떨어진다. 하지만 리눅스 스케줄러는 가능한 한 기존에 바인딩된 노드에 계속 바인딩되도록 하려는 경향이 있기 때문에 한쪽 노드에서 할당 가능한 메모리의 양을 넘지 않는 한 크게 문제되지 않는다.
2. **bind**
    1. membid 
        - 중간에 cpu를 바꿔도, 초기에 할당한 노드의 메모리에서만 계속 할당 받는다.
        - 할당받는 노드의 메모리를 다 쓰면 (다른 노드의 메모리가 있어도) swap 영역을 사용하다가 결국 OOM으로 프로스가 중지된다.
        - 비권장 방식
    2. cpunodebind
        - 특정 노드에 있는 cpu에서만 프로세스가 돌아가도록 설정
        - 메모리 지역성이 좋다.
        - 해당 노드에 할당받을 메모리가 없어지면 다른 노드를 통해 메모리를 할당 받음
        - 멀테스레드로 동작하는 경우 cpu를 절반밖에 사용할 수 없다.
    3. physcpubind
        - 프로세스를 특정 노드 cpu 에 매핑하는 것이 아닌, <u>cpu 번호에</u> 매핑한다.
3. **preferred**
    - bind와 비슷하지만 설정한 노드 이상의 메모리를 사용하게 되면, 다른 노드로부터 메모리를 할당받기 때문에 OOM이 발생하지 않는다.
4. **interleaved**
    - 어느 노드에 속한 cpu에서 돌아가고 있건 상관 없이 각 노드들로부터 순차적으로 메모리 할당을 받게 된다.
    
> `tskset -pc <cpunum> <pid>` : 프로세스 cpu 변경

### numad 를 이용한 메모리 할당 관리
`numad`
- 시스템에 상주하면서 프로세스들이 메모리 할당 과정을 주기적으로 살펴보고, cpu나 메모리에 대한 유연성을 조절, 프로세스들을 최적화 시킴
- 대체로 좋은 성능을 만들지만 아닐 때도 있다.

### vm.zone_reclaim_mod 커널 파라미터
#### zone
- 커널은 메모리를 사용 용도에 따라 zone 이라 부르는 영역을 구분하여 관리한다. 
- zone 에 대한 정보는 `/proc/buddyinfo` 파일을 통해 확인 가능
- zone 영역 
    1. DMA/DMA32 : Direct Memory Access의 약자로 주로 오래된 하드웨어의 동작을 위해 존해하는 영역
    2. Normal : 일반적인 용도, 커널, 프로세스 등이 메모리를 필요로 할 때 Normal 영역에서 메모리를 할당 받아서 사용한다.

#### vm.zone_reclaim_mod
- zone 사이에서 특정 영역의 메모리가 부족할 경우 다른 영역의 메모리 할당 여부를 설정하는 값
- 총 4개의 값을 설정 가능하나 0 ,1 이 메인
    - 0 
        - zone안에서 재할당 하지 않고 다른 zone 에서 가져와서 사용
        - page cache 등과 같은 재할당 대상 메모리들이 반환되지 않고 다른 노드에 있는 메모리를 할당 받아서 사용
        - 메모리 로컬 액세스 이점 보다  page cache 확보가 더 중요한 서버에서 사용
    - 1 
        - 메모리가 부족한 상황이 되면 해당 zone 안에서 재할당할 수 있는 메모리 영역을 찾아서 재할당해 사용하게 함
        - page cache 확보 보다는 로컬 액세스 방식이 성능상 더 유리할 때 사용하는 설정값

### NUMA 아키텍처 메모리 할당정책과 워크로드
- NUMA 시스템에서 워크로드를 확인하는 방법중에 가장 먼저 생각해 볼 것은 사용할 메모리의 크기와 프로세스의 스레드 개수이다

#### 워크로드별 최적화 방법
1. 메모리가 노드하나 크기를 넘지 않는 싱글스레드 
    - Bind정책으로 특정 cpu에 바인딩하고, 
     vm.zone_reclaim_mode = 1 로 설정해 로컬 액세스의 성능을 누리는 것이 좋다.
2. 메모리가 노드하나 크기를 넘지 않는 멀티스레드
    - cpunodebind 모드로 여러개의 코어에 프로세스를 바인딩 시키고 해당 노드에서만 메모리를 할당 받기.
    - vm.zone_reclaim_mode = 1
3. 메모리가 노드하나 크기를 넘는 싱글스레드
    - cpunodebind 정책으로 메모리 지역성을 최대한 높이고 리모트 액세스를 최소화 시킨다.
    - vm.zone_reclaim_mode = 0
4. 메모리가 노드하나 크기를 넘는 멀티스레드
    - 리모드엑세스 발생이 필요하고, 여러개의 스레드가 여러개의 cpu를 동작하므로 interleave 모드가 최적의 성능을 낼 수 있다.
    - 어떤 cpu에 어떤 스레드가 바인딩 될지 모르게 때문에 가능한 한 메모리 할당을 여러 영역에 넓게 펼치는 것이 유리하다.
    - vm.zone_reclaim_mode = 0