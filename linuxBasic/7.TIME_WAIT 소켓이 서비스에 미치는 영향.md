# TIME_WAIT 소켓이 서비스에 미치는 영향
 
## TCP 통신 과정
### 3-way handshake
1. 클라이언트는 서버로 통신을 시작하겠다는 SYN(Synchronization)을 보내고
2. 서버는 그 응답으로 SYN + ACK(Acknowledgement) 를 보낸다
3. 클라이언트는 서버로부터 받은 패킷에 대한 응답으로 ACK를 보냄
### 4-way handshake
![](./img/handshake.PNG)
(3-way handshake를 정상적으로 마친 이후) 
1. 클라이언트가 서버에 데이터를 요청
2. 서버는 응답(DATA)를 주고 연결을 끊기 위해 FIN(Finish) 패킷을 보냄
3. 클라이언트는 위 패킷에 대한 응답으로 ACK 패킷을 보냄
4. 클라이언트는 자신이 사용한 소켓을 정리하며 통신을 완전히 끝내도 된다는 의미의 FIN 패킷을 보냄
5. 서버는 클라이언트의 패킷에 대한 응답으로 ACK 패킷을 보냄  
 -> **이때 TIME_WAIT 소켓이 생성된다. 이 TIME_WAIT 소켓은 일정 시간이 지난 후 CLOSED 된다.**

## TIME_WATI 소켓 생성
- TCP 연결을 끊을 때 먼저 연결을 끊는 쪽을 active closer라고 하고, 그 반대를 passive closer라고 한다.
    이때 <u>**active closer 쪽에서 TIME_WAIT 소켓이 생성된다**</u>
- `netstat -napo | grep -i time_wait` : TIME_WAIT 상태의 소켓 확인 

## 클라이언트 입장에서의 TIME_WAIT 소켓
#### 클리이언트에서 소켓이 생성되는 과정
1. 애플리케이션이 (DB서버와의 통신등을 위해) 커널에 소켓 생성요청
2. 커널이 로컬포트 목록중 사용가능한 포트 하나를 할당
3. 애플리케이션은 할당받은 번호로 커널에 소켓 생성 요청
4. 커널이 해당 정보로 소켓 생성
    > 소켓은 출발지 IP, 출발지 Port, 목적지 IP, 목적지 Port 4개의 값을 한 묶음으로 해서 생성하며, 해당 소켓은 커널 내부에 유일하게 존재한다.
5. 소켓 생성이 정상적으로 완료되면 커널이 소켓 접근에 사용할 FD(File DEscriptor) 전달
#### 클리이언트에서 TIME_WAIT 소켓 문제
 사용된 소켓을 acive close 하게 되면 TIME_WAIT 상태로 남고, 해당 소켓은 TIME_WAIT 상태가 풀려서 커널로 다시 돌아갈 때까지 다시 사용할 수 없다.  
 이런 식으로 TIME_WAIT 소켓이 쌓이면 더이상 할당할 수 있는 로컬 포트가 없어서 사용자의 요청을 처리할 수 없게된다.
#### 로컬 포트 고갈에 대한 대응
1. `net.ipv4.tcp_tw_reuse` 
    - 외부로 요청할 때 TIME_WAIT 소켓을 재사용 할 수 있게 하는 파라미터
    - 위 파라미터 값을 1로 설정하면 TW 상태의 동일한 쌍의 소켓이 있는 경우 해당값을 사용하도록 그대로 리턴 시켜준다.
    > net.ipv4.tcp_tw_reuse 는 timestamp 기능과 함께 사용해야 하고, 
    > net.ipv4.tcp_timestamps 값이 반드시 1이어야 한다.

2. ConnectionPool 방식
    - 미리 소켓을 열어놓고 요청을 처리하는 방식으로, 로컬포트의 무분별한 사용을 막을 수 있고, 불필요한 TCP 연결 맺기/끊기 과정이 없어서 응답속도가 더 좋다.

## 서버 입장에서의 TIME_WAIT 소켓
- 서버는 소켓을 열어놓고 요청을 받아들이기 때문에 로컬포트 고갈 문제는 없다
- 다수의 소켓 TIME_WAIT 소켓이 있으면 불필요한 연결 맺기/끊기의 과정이 반복된다.

### `net.ipv4.tcp_tw_recycle`
- 서버 입장에서 TIME_WAIT 상태의 소켓을 빠르게 회수하고 재활용할 수 있게 해주는 파라미터
- 설정시 다음 두가지 작업을 추가로 진행한다.
    1. 가장 마지막에 해당 소켓으로부터 들어온 timestamp 저장
    2. TIME_WAIT 소켓의 타이머를 RTO 기반의 값으로 변경
    > TIME_WAIT 소켓의 기본 타임아웃은 1분이다.
- 문제점
    - C1(첫번째 클라이언트), C2(두번째 클라이언트)가 동일한 통신사를 사용하면 서버 입장에서는 같은 클라이언트로 보게 된다.  
    서버는 C1과의 통신을 마무리하고 TIME_WAIT소켓을 RTO값으로 세팅해서 금방 정리하고, C1의 Timestamp값을 저장한다.  
    그 후 C2가 연결 오픈 요청을 보내게 될때 Timestamp값이 C1이 보낸 FIN에 기록된 Timestamp보다 작으면 서버 입장에서는 잘못된 연결 요청으로 판단하고 패킷을 처리하지 않고 버린다.  
    C2는 응답이 오지 않아 연결요청을 계속해서 보내게 된다. 
    - 따라서 클라이언트의 요청을 직접 받는 웹 서버에서는 tw_recycle을 절대로 켜서는 안된다.

### `keepalive`
- 한번 맺은 세션을 요청이 끝나더라도 유지해주는 기능
- `keepalive_timeout 10` : 요청을 끝마쳐도 연결이 끊어지지 않고 10초 동안 연결이 유지되어 있게 된다.

## TIME_WAIT 상태의 존재 이유
- TIME_WAIT 소켓은 연결 종료 후에도 소켓을 바로 정리하지 않고 일종의 연결 종료에 대한 흔적을 남겨놓는 데에 있다.
- TIME WAIT 상태가 없다면 다음과 같은 문제가 발생 할 수 있다.
   > 1. 클라이언트와 서버 통신 종료시 서버에서 마지막으로 보낸 ACK가 유실됨
   > 2. 클라이언트에서 ACK를 받지 못하면 FIN을 다시 한번 더 보내게 된다. 
   > 3. 서버측에서 TIME_WAIT 소켓을 정리해버렸기 때문에 클라이언트가 보낸 FIN이 비정상적이라고 판단해서 RST를 보냄
   > 4. 클라이언트는 정리해야하는 소켓에대해 정상적인 ACK를 받지못해서 소켓이 LAST_ACK 상태로 계속 남아있게 된다.
