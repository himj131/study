### 좋은 테스트 조건

### 잘못된 테스트 
- 테스트 사용자에게 아무 정보도 주지못하는 테스트
- 산발적으로 실패하는 테스트
- 어떤 가치도 증명하지 못하는 테스트
- 실행하는 데 오래 걸리는 테스트
- 코드를 충분히 커버하지 못하는 테스트
- 구현과 강하게 결합되어 있는 테스트 -> 작은 변화에도 많은 테스트가 깨진다
- 수많은 설정고리로 점프하는 난해한 테스트

## 좋은 테스트의 조건
- [F]ast :  빠른
- [I]solated : 고립된
- [R]epeatable :  반복 가능한
- [S]elf-validating : 스스로 검증 가능한
- [T]imely : 적시의  

### [F]irst :  빠르다
- 단위테스트의 가치가 높다는 것은 대상 시스템에 대한 지속적이고 종합적인 빠른 피드백을 준다는 것
- 설계를 깨끗하게 하면 테스트를 빠르게 유지 할 수 있다.
- 느린 테스트에 대한 의존성을 줄이기
- 코드를 클린 객체 지향 설계 개념과 맞출수록 단위 테스트 작성도 쉬워진다.

### F[I]rst :  고립시킨다.
- 좋은 단위 테스트는 검증하려는 작은 양의 코드에 집중한다.
- 테스트 코드와 상호 작용하는 코드가 많을수록 문제 발생 할 소지가 늘어난다.
    - 단위 테스트는 다른 단위 테스트에 의존 하지 않는다.
    - 외부저장소와 상호작용하게 되면 가용성이나 접근성의 이유로 실패할 확률이 늘어난다.
- 테스트가 하나이상의 이유로 깨진다면 테스트 분리를 고려해야한다.

### FI[R]st : 좋은 테스트는 반복 가능해야 한다
- 실행할 때마다 결과가 같아야 한다.
- 반복가능한 테스트를 만들려면 직접 통제할수 없는 외부 환경과 격리 시켜야 한다.
    - 현재 시간과 같이 통제할수 없는 객체를 다룰때에는 java.time.Clock객체 등을 사용하여 고정된 시간 반환 가능
### FIR[S]t : 스스로 검증 가능하다
- 테스트에 기대하는것이 무엇인지 단언함으로써 스스로 검증 가능하게 한다.
- 테스트에 필요한 모든 설정 단계도 자동화 시킨다.

### FIRS[T] : 적시에 사용한다.
- 단위 테스트를 많이 할 수록 테스트 대상 코드가 줄어들고 테스트 작성도 쉬워진다.


## 마치며
테스트 코드가 그에 상응하는 가치가 있다고 해도, 이런 테스트 코드 역시 유지보수해야하는 대상이다.  
테스트 코드를 고품질로 유지해야 그 가치도 계속 유지 될 수 있다.
 

